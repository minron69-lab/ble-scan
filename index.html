<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8">
  <title>BLE Raw 掃描測試（含支援偵測與 fallback）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { font-family: Arial, sans-serif; padding:20px; }
    button { margin:4px; padding:8px 12px; }
    pre { background:#111; color:#0f0; padding:10px; max-height:420px; overflow:auto; }
    .hint { color:#555; margin-top:6px; }
  </style>
</head>
<body>
  <h2>Web Bluetooth Raw 掃描</h2>
  <div>
    <button id="scan">開始掃描 raw（不連線）</button>
    <button id="stop" disabled>停止掃描</button>
    <button id="fallback">改用連線 (requestDevice)</button>
  </div>
  <div class="hint">
    建議用 <b>Android 版 Chrome</b>，並在 <code>chrome://flags</code> 啟用
    <b>Experimental Web Platform features</b>。<br>
    若 10 秒內沒有任何廣告，會顯示排查建議。
  </div>

  <h3>Log</h3>
  <pre id="log">準備中…</pre>

<script>
const $ = (id)=>document.getElementById(id);
const logEl = $('log');
const btnScan = $('scan'), btnStop = $('stop'), btnFallback = $('fallback');

function log(...a){
  const txt = a.map(x => typeof x==='object' ? JSON.stringify(x,null,2) : String(x)).join(' ');
  logEl.textContent = new Date().toLocaleTimeString()+'  '+txt+'\n'+logEl.textContent;
}
function ab2hex(buf){ return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,'0')).join(''); }
function setScanUI(scanning){ btnScan.disabled=scanning; btnStop.disabled=!scanning; }

let watcher=null, advHandler=null, abortCtrl=null, firstSeenTs=null, timeoutId=null;

function cleanup(){
  try{ advHandler && navigator.bluetooth.removeEventListener('advertisementreceived', advHandler);}catch(e){}
  advHandler=null;
  try{ watcher && watcher.stop(); }catch(e){}
  watcher=null;
  try{ abortCtrl && abortCtrl.abort(); }catch(e){}
  abortCtrl=null;
  if (timeoutId){ clearTimeout(timeoutId); timeoutId=null; }
  setScanUI(false);
}

function envCheck(){
  log('環境檢查：navigator.bluetooth =', !!navigator.bluetooth);
  log('支援 requestLEScan =', !!(navigator.bluetooth && 'requestLEScan' in navigator.bluetooth));
}

envCheck();

btnScan.onclick = async () => {
  if (!navigator.bluetooth || !('requestLEScan' in navigator.bluetooth)){
    log('❌ 此環境不支援 raw 掃描（requestLEScan）。請改用 Android Chrome 或按下「改用連線」。');
    return;
  }
  try{
    abortCtrl = new AbortController();
    watcher = await navigator.bluetooth.requestLEScan({
      acceptAllAdvertisements: true,
      keepRepeatedDevices: true,
      signal: abortCtrl.signal
    });
    setScanUI(true);
    firstSeenTs = null;
    log('✅ 開始掃描…（請將裝置靠近，並確認它在廣播）');

    // 若 10 秒內完全沒收到任何廣告，給提示
    timeoutId = setTimeout(() => {
      if (!firstSeenTs){
        log('⚠️ 10 秒內未收到廣告：');
        log('  1) 確認 Android Chrome，且已啟用 Experimental Web Platform features');
        log('  2) 檢查站台/系統權限：藍牙、附近裝置、位置');
        log('  3) 用 nRF Connect 確認裝置真的在廣播（未連線狀態）');
      }
    }, 10000);

    advHandler = (e)=>{
      if (!firstSeenTs) firstSeenTs = Date.now();
      const name = e.device.name || '(no name)';
      log(`🔹 ADV name=${name} id=${e.device.id} RSSI=${e.rssi} tx=${e.txPower}`);
      if (e.uuids?.length) log('  UUIDs:', e.uuids.join(', '));
      if (e.manufacturerData?.size){
        for (const [cid, dv] of e.manufacturerData){
          log(`  MFD companyId=${cid} hex=${ab2hex(dv.buffer)}`);
        }
      } else {
        log('  (無 manufacturerData)');
      }
      if (e.serviceData?.size){
        for (const [uuid, dv] of e.serviceData){
          log(`  SVC ${uuid} hex=${ab2hex(dv.buffer)}`);
        }
      }
    };
    navigator.bluetooth.addEventListener('advertisementreceived', advHandler);

  } catch(err){
    log('⚠️ 掃描未開始（可能關閉或拒絕權限）：', err.name || err.message);
    cleanup();
  }
};

btnStop.onclick = () => {
  cleanup();
  log('⏹️ 已停止掃描');
};

// Fallback：不支援 raw 時，至少讓你選裝置並讀幾個 characteristic
btnFallback.onclick = async () => {
  if (!navigator.bluetooth){
    log('❌ 此瀏覽器不支援 Web Bluetooth。');
    return;
  }
  try{
    const device = await navigator.bluetooth.requestDevice({
      acceptAllDevices: true,
      optionalServices: ['generic_access','device_information']
    });
    log('選到裝置：', device.name || '(no name)', 'id=', device.id);
    device.addEventListener('gattserverdisconnected', () => log('裝置已斷線：', device.name || device.id));
    const server = await device.gatt.connect();
    log('GATT 已連線');
    try{
      const svc = await server.getPrimaryService('device_information');
      const chars = await svc.getCharacteristics();
      for (const c of chars){
        log('Characteristic:', c.uuid, ' props=', JSON.stringify(c.properties));
        if (c.properties.read){
          const v = await c.readValue();
          log('  讀到值(hex):', ab2hex(v.buffer));
        }
      }
    }catch(e){ log('讀取 device_information 失敗：', e.message || e); }
  }catch(e){
    log('未連線（可能取消/拒絕）：', e.name || e.message || e);
  }
};
</script>
</body>
</html>
